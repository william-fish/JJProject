# 数据流向说明文档

## 一、数据架构概览

程序采用**三层数据架构**，由统一的 `DataManager` 串联：
1. **持久化层**：JSON文件（磁盘存储）
2. **内存层**：`DataManager` 管理的缓存字典（运行时数据）
3. **业务层**：业务逻辑函数（通过接口访问数据）

---

## 二、数据分类

### 2.1 核心数据（用户状态数据）

#### 1. **老婆数据 (wives_data)**
- **文件**：`wives_global.json`
- **内存缓存**：`wives_data`（由 `DataManager` 缓存）
- **结构**：`{uid: {nick, wives: [], date, harem, groups: []}}`
- **特点**：跨群共享，永久保存
- **加载**：`DataManager.register_store()` 启动时自动加载并兼容旧格式
- **保存**：`save_wife_data()` 自动委托给 `DataManager.save("wives_data")`
- **访问**：通过 `get_group_record()`, `ensure_group_record()` 等函数

#### 2. **道具数据 (item_data)**
- **文件**：`items.json`
- **内存缓存**：`item_data`（由 `DataManager` 缓存）
- **结构**：`{date: {uid: [item1, item2, ...]}}`
- **特点**：按日期存储，每日清理旧数据
- **加载**：通过 `DataManager` 自动注册
- **保存**：`save_item_data()` 统一调用 `DataManager.save("item_data")`
- **清理**：`cleanup_daily_data()` - 每日清理非当日数据

#### 3. **效果数据 (effects_data)**
- **文件**：`effects.json`
- **内存缓存**：`effects_data`（由 `DataManager` 缓存）
- **结构**：`{date: {uid: {flags: {}, mods: {}, meta: {}}}}`
- **特点**：按日期存储，包含状态、修正值、元数据
- **加载**：`DataManager` 自动加载
- **保存**：`save_effects()` 统一调用 `DataManager.save("effects_data")`
- **清理**：`cleanup_daily_data()` - 每日清理非当日数据
- **存档**：通过 `archives` 永久保存历史数据

#### 4. **运势数据 (fortune_data)**
- **文件**：`fortune.json`
- **内存缓存**：`fortune_data`（由 `DataManager` 缓存）
- **结构**：`{date: {uid: {type, stars, lucky_star, wife_img, proverb, dos, donts, tags}}}`
- **特点**：按日期存储，每个用户每天一个运势
- **加载**：`DataManager` 自动加载
- **保存**：`save_fortune_data()` 统一托管
- **清理**：`cleanup_daily_data()` - 每日清理非当日数据

---

### 2.2 记录数据（操作历史）

#### 1. **NTR记录 (ntr_records)**
- **文件**：`ntr_records.json`
- **内存变量**：`ntr_records` (全局字典)
- **结构**：`{uid: {date, count}}`
- **加载**：`load_ntr_records()` - 支持旧格式迁移
- **保存**：`save_ntr_records()`

#### 2. **换老婆记录 (change_records)**
- **文件**：`change_records.json`
- **内存变量**：`change_records` (全局字典)
- **结构**：`{uid: {date, count}}`
- **加载**：`load_change_records()` - 支持旧格式迁移
- **保存**：`save_change_records()`

#### 3. **其他记录数据**
- `select_wife_records` - 选老婆记录
- `beat_wife_records` - 打老婆记录
- `seduce_records` - 勾引记录
- `reset_blind_box_records` - 重置盲盒记录
- `gift_records` - 赠送记录
- `request_records` - 索取记录

---

### 2.3 请求数据（临时状态）

#### 1. **交换请求 (swap_requests)**
- **文件**：`swap_requests.json`
- **内存变量**：`swap_requests` (全局字典)
- **结构**：`{gid: {requester_uid: {target_uid, requester_nick, target_nick, timestamp}}}`
- **特点**：临时数据，每日清理

#### 2. **赠送请求 (gift_requests)**
- **文件**：`gift_requests.json`
- **内存变量**：`gift_requests` (全局字典)
- **结构**：`{date: {gid: {sender_uid: {receiver_uid, item_name, sender_nick, receiver_nick}}}}`
- **特点**：按日期存储，每日清理

---

### 2.4 配置数据（系统配置）

#### 1. **市场数据 (market_data)**
- **文件**：`market.json`
- **内存变量**：`market_data` (全局字典)
- **特点**：市场配置，不按日期清理

#### 2. **盲盒加成 (blind_box_perks)**
- **文件**：`blind_box_perks.json`
- **内存变量**：`blind_box_perks` (全局字典)
- **结构**：`{uid: {perk_type: value}}`
- **特点**：永久数据，跨日期保存

#### 3. **存档数据 (archives)**
- **文件**：`archives.json`
- **内存变量**：`archives` (全局字典)
- **结构**：`{date: {uid: {wives, effects, items}}}`
- **特点**：历史快照，永久保存

---

## 三、数据流向图

### 3.1 启动时数据加载流程

```
程序启动
    ↓
加载所有数据文件（按顺序）：
    ├─ load_wife_data()          → wives_data
    ├─ load_item_data()          → item_data
    ├─ load_effects()            → effects_data
    ├─ load_fortune_data()       → fortune_data
    ├─ load_ntr_statuses()       → ntr_statuses
    ├─ load_ntr_records()        → ntr_records
    ├─ load_change_records()     → change_records
    ├─ load_swap_requests()      → swap_requests
    ├─ load_market_data()        → market_data
    ├─ load_gift_requests()      → gift_requests
    ├─ load_archives()           → archives
    └─ ... (其他记录数据)
    ↓
清理过期数据（cleanup_gift_requests()）
    ↓
程序就绪
```

### 3.2 运行时数据操作流程

#### 典型操作：用户抽盲盒

```
用户指令：抽盲盒
    ↓
cleanup_daily_data(today)  # 清理旧日期数据
    ↓
get_user_effects(today, uid)  # 从 effects_data 读取状态
    ↓
_draw_item_by_quality()  # 计算抽卡概率
    ↓
修改 item_data[today][uid]  # 添加道具
    ↓
save_item_data()  # 保存到 items.json
    ↓
返回结果
```

#### 典型操作：用户使用道具

```
用户指令：使用道具
    ↓
从 item_data[today][uid] 读取道具列表
    ↓
apply_item_effect()  # 执行道具效果
    ├─ 修改 effects_data[today][uid]  # 更新状态
    ├─ 修改 wives_data[uid]  # 修改老婆数据
    └─ 可能触发其他数据修改
    ↓
save_effects()  # 保存效果数据
save_wife_data()  # 保存老婆数据
    ↓
从 item_data[today][uid] 移除道具
    ↓
save_item_data()  # 保存道具数据
    ↓
返回结果
```

#### 典型操作：用户查看状态

```
用户指令：查状态
    ↓
get_user_effects(today, uid)  # 从 effects_data 读取
get_wives_list(cfg, uid, today)  # 从 wives_data 读取
get_user_items(today, uid)  # 从 item_data 读取
get_fortune(today, uid)  # 从 fortune_data 读取
    ↓
生成状态面板图片
    ↓
返回结果（不涉及数据保存）
```

---

## 四、数据访问模式

### 4.1 直接访问模式（不推荐）

```python
# 直接访问全局变量
wives_data[uid]["wives"].append(wife)
item_data[today][uid].append(item)
```

### 4.2 函数访问模式（推荐）

```python
# 通过函数访问和修改
add_wife(cfg, uid, wife_img, today, nick)
get_user_flag(today, uid, "flag_name")
set_user_flag(today, uid, "flag_name", True)
get_user_items(today, uid)
```

### 4.3 群配置访问模式

```python
# 通过 GroupConfigDict 访问
cfg = load_group_config(gid)
record = cfg.get(uid)
# 修改后需要保存
save_group_config(cfg)
```

---

## 五、数据保存策略

### 5.1 立即保存策略

以下数据修改后**立即保存**：
- `wives_data` → `save_wife_data()`
- `item_data` → `save_item_data()`
- `effects_data` → `save_effects()`
- `fortune_data` → `save_fortune_data()`
- 所有记录数据 → 对应的 `save_*()` 函数

### 5.2 延迟保存策略

以下数据**批量保存**或**按需保存**：
- `archives` → 存档时保存
- `market_data` → 市场更新时保存

### 5.3 自动清理策略

以下数据**每日自动清理**：
- `item_data` - 只保留当日数据
- `effects_data` - 只保留当日数据（存档已保存）
- `fortune_data` - 只保留当日数据
- `gift_requests` - 只保留当日请求
- 各种记录数据 - 只保留当日记录

---

## 六、数据流向问题与已落地优化

### 6.1 历史痛点

1. **数据分散**：核心数据散落在多个全局变量中，缺乏统一管理
2. **保存时机不统一**：不同模块各自决定何时写盘，存在覆盖风险
3. **访问方式混乱**：直接读写全局字典，可维护性差
4. **缺乏事务**：多数据写入过程中出错会留下脏数据

### 6.2 已完成的措施

1. **统一数据访问接口**：依赖 `DataManager.register_store/get/save`
2. **数据管理器**：集中封装加载、缓存、保存逻辑
3. **事务支持**：`DataTransaction` 为 `use_item` 等流程提供回滚能力
4. **数据版本控制**：`data_versions.json` 记录数据集版本，便于迁移
5. **缓存机制**：`load_group_config` 增加 LRU 缓存，`save_wife_data` 自动失效

---

## 七、关键数据流路径

### 7.1 用户数据生命周期

```
用户首次使用
    ↓
创建用户记录（wives_data, effects_data）
    ↓
生成运势（fortune_data）
    ↓
抽盲盒获得道具（item_data）
    ↓
使用道具修改状态（effects_data）
    ↓
每日数据清理（保留存档到 archives）
    ↓
新的一天重新开始
```

### 7.2 数据同步流程

```
内存数据修改
    ↓
调用对应的 save_*() 函数
    ↓
save_json() 原子写入
    ├─ 创建临时文件
    ├─ 写入数据
    ├─ 刷新到磁盘
    └─ 原子替换原文件
    ↓
数据持久化完成
```

---

## 八、数据文件清单

### 8.1 核心数据文件
- `wives_global.json` - 老婆数据（全局）
- `items.json` - 道具数据
- `effects.json` - 效果数据
- `fortune.json` - 运势数据

### 8.2 记录数据文件
- `ntr_records.json` - NTR记录
- `change_records.json` - 换老婆记录
- `select_wife_records.json` - 选老婆记录
- `beat_wife_records.json` - 打老婆记录
- `seduce_records.json` - 勾引记录
- `reset_blind_box_records.json` - 重置盲盒记录
- `gift_records.json` - 赠送记录
- `request_records.json` - 索取记录

### 8.3 请求数据文件
- `swap_requests.json` - 交换请求
- `gift_requests.json` - 赠送请求

### 8.4 配置数据文件
- `market.json` - 市场配置
- `blind_box_perks.json` - 盲盒加成
- `archives.json` - 存档数据
- `pro_user.json` - 专业用户配置
- `discarded_items.json` - 回收站数据
- `user_interactions.json` - 用户交互记录

---

## 九、总结

程序的数据流向遵循以下原则：

1. **启动时加载**：所有数据在程序启动时从JSON文件加载到内存
2. **运行时操作**：所有数据操作在内存中进行
3. **立即保存**：数据修改后立即保存到JSON文件
4. **每日清理**：每日自动清理过期数据，保留存档
5. **格式兼容**：支持旧格式自动迁移到新格式

数据流向清晰，但存在一些可以优化的地方，建议按照上述优化建议进行改进。

---

## 十、架构改进与支撑组件

### 10.1 DataManager
- 统一注册 `wives_data`、`item_data`、`effects_data`、`fortune_data`
- 自动执行加载、缓存、保存
- 对外只暴露 `register_store/get/save` 接口，屏蔽 JSON 细节

### 10.2 DataTransaction
- `with data_manager.transaction(...):` 提供批量修改能力
- 异常时回滚内存快照，避免写入脏数据
- 正常结束统一刷新挂起的数据集

### 10.3 数据版本控制
- 新增 `data_versions.json`，记录每个数据集的结构版本
- 数据结构升级时自动写入，便于后续迁移/回滚

### 10.4 GroupConfig 缓存
- `load_group_config()` 增加 LRU 缓存，减轻频繁构建开销
- `save_wife_data()` 自动清空/刷新缓存，保证读取一致性

这些组件保证了数据访问的一致性与可靠性。

